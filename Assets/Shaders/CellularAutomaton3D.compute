#pragma kernel Init
#pragma kernel Next
#pragma kernel PrepareBuffer
#pragma kernel ApplyBuffer

#include "Random.cginc"
#include "CellularAutomaton.cginc"

struct Cube
{
    float3 Position;
    float3 Color;
    int State;
};

RWStructuredBuffer<Cube> _CubesBuffer;
RWStructuredBuffer<Cube> _Cubes;
float _InitRandomStep;
int _InitCenterWidth;

int getUID(uint3 id)
{
    return id.x + id.y * _Resolution + id.z * _Resolution * _Resolution;
}

int getMooreNeighboursCount(uint3 id)
{
    int neighboursCount = 0;

    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                if (x == 0 && y == 0 && z == 0)
                    continue;

                int3 neighbourID = id + int3(x,y,z);
                if (neighbourID.x >= _Resolution || neighbourID.y >= _Resolution || neighbourID.z >= _Resolution)
                    continue;
                
                uint neighbourUID = getUID(neighbourID);
                Cube neighbour = _Cubes[neighbourUID];
                neighboursCount += neighbour.State == _Rules.z - 1 ? 1 : 0;
            }
        }
    }

    return neighboursCount;
}

int getNeumannNeighboursCount(uint3 id)
{
    int neighboursCount = 0;

    // Negative X.
    int3 neighbourID = id + int3(-1,0,0);
    if (neighbourID.x <= _Resolution)
    {
        uint neighbourUID = getUID(neighbourID);
        Cube neighbour = _Cubes[neighbourUID];
        neighboursCount += neighbour.State == _Rules.z - 1 ? 1 : 0;
    }
    // Positive X.
    neighbourID = id + int3(1,0,0);
    if (neighbourID.x <= _Resolution)
    {
        uint neighbourUID = getUID(neighbourID);
        Cube neighbour = _Cubes[neighbourUID];
        neighboursCount += neighbour.State == _Rules.z - 1 ? 1 : 0;
    }

    // Negative Y.
    neighbourID = id + int3(0,-1,0);
    if (neighbourID.y <= _Resolution)
    {
        uint neighbourUID = getUID(neighbourID);
        Cube neighbour = _Cubes[neighbourUID];
        neighboursCount += neighbour.State == _Rules.z - 1 ? 1 : 0;
    }
    // Positive Y.
    neighbourID = id + int3(0,1,0);
    if (neighbourID.y <= _Resolution)
    {
        uint neighbourUID = getUID(neighbourID);
        Cube neighbour = _Cubes[neighbourUID];
        neighboursCount += neighbour.State == _Rules.z - 1 ? 1 : 0;
    }

    // Negative Z.
    neighbourID = id + int3(0,0,-1);
    if (neighbourID.z <= _Resolution)
    {
        uint neighbourUID = getUID(neighbourID);
        Cube neighbour = _Cubes[neighbourUID];
        neighboursCount += neighbour.State == _Rules.z - 1 ? 1 : 0;
    }
    // Positive Z.
    neighbourID = id + int3(0,0,1);
    if (neighbourID.z <= _Resolution)
    {
        uint neighbourUID = getUID(neighbourID);
        Cube neighbour = _Cubes[neighbourUID];
        neighboursCount += neighbour.State == _Rules.z - 1 ? 1 : 0;
    }

    return neighboursCount;
}

[numthreads(8,8,8)]
void Init(uint3 id : SV_DispatchThreadID)
{
    float halfResolution = _Resolution / 2;
    float halfInitCenterWidth = ceil(_InitCenterWidth / 2.0);
    int display = step(random(id.xyz), _InitRandomStep);

    uint uid = getUID(id);
    _Cubes[uid].Position = float3(id.xyz);

    int3 sid = id;
    
    if (_InitCenterWidth == 1)
    {
        _Cubes[uid].State = display == 1 && sid.x == halfResolution && sid.y == halfResolution && sid.z == halfResolution ? _Rules.z - 1 : 0;
    }
    else
    {
        _Cubes[uid].State = display == 1
                            && sid.x > halfResolution - halfInitCenterWidth
                            && sid.x < halfResolution + halfInitCenterWidth
                            && sid.y > halfResolution - halfInitCenterWidth
                            && sid.y < halfResolution + halfInitCenterWidth
                            && sid.z > halfResolution - halfInitCenterWidth
                            && sid.z < halfResolution + halfInitCenterWidth ? _Rules.z - 1 : 0;
    }
}

[numthreads(8,8,8)]
void Next(uint3 id : SV_DispatchThreadID)
{
    int uid = getUID(id);
    Cube cube = _Cubes[uid];
    int neighbours = _Rules.w == 0 ? getMooreNeighboursCount(id) : getNeumannNeighboursCount(id);
    neighbours = pow(2, neighbours);

    if (cube.State == 0) // Dead.
    {
        if ((neighbours & _Rules.y) != 0 && _Rules.y > -1)
            _CubesBuffer[uid].State = _Rules.z - 1;
    }
    else if (cube.State == _Rules.z - 1) // Alive
    {
        if ((neighbours & _Rules.x) == 0 && _Rules.x > -1)
            _CubesBuffer[uid].State--;
    }
    else // Dying.
    {
        _CubesBuffer[uid].State--;
    }
}

[numthreads(8,8,8)]
void PrepareBuffer(uint3 id : SV_DispatchThreadID)
{
    int uid = getUID(id);
    _CubesBuffer[uid] = _Cubes[uid];
}

[numthreads(8,8,8)]
void ApplyBuffer(uint3 id : SV_DispatchThreadID)
{
    int uid = getUID(id);
    _Cubes[uid] = _CubesBuffer[uid];
}
