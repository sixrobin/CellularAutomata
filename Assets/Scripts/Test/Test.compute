#pragma kernel InitRandom
#pragma kernel InitCenterCell
#pragma kernel ColorFromNeighbours
#pragma kernel Next
#pragma kernel PrepareBuffer
#pragma kernel ApplyBuffer

#include "Assets/Shaders/Random.cginc"

struct Cube
{
    float3 Position;
    float3 Color;
    float State;
};

RWTexture2D<float4> Result;
RWStructuredBuffer<Cube> _CubesBuffer;
RWStructuredBuffer<Cube> _Cubes;
float _Resolution;
float _InitRandomStep;
int4 _Rules;

int getUID(uint3 id)
{
    return id.x + id.y * _Resolution + id.z * _Resolution * _Resolution;
} 

int getMooreNeighboursCount(uint3 id)
{
    int neighboursCount = 0;

    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                if (x == 0 && y == 0 && z == 0)
                    continue;

                int3 offset = int3(x,y,z);
                uint3 neighbourID = id + offset;

                if (neighbourID.x >= _Resolution || neighbourID.y >= _Resolution || neighbourID.z >= _Resolution)
                    continue;
                
                uint neighbourUID = getUID(neighbourID);
                Cube neighbour = _Cubes[neighbourUID];
                neighboursCount += neighbour.State;
            }
        }
    }

    return neighboursCount;
}

int getNeumannNeighboursCount(uint3 id)
{
    int neighboursCount = 0;

    // Negative X.
    int3 offset = int3(-1,0,0);
    uint3 neighbourID = id + offset;
    if (neighbourID.x <= _Resolution)
    {
        uint neighbourUID = getUID(neighbourID);
        Cube neighbour = _Cubes[neighbourUID];
        neighboursCount += neighbour.State;
    }
    // Positive X.
    offset = int3(1,0,0);
    neighbourID = id + offset;
    if (neighbourID.x <= _Resolution)
    {
        uint neighbourUID = getUID(neighbourID);
        Cube neighbour = _Cubes[neighbourUID];
        neighboursCount += neighbour.State;
    }

    // Negative Y.
    offset = int3(0,-1,0);
    neighbourID = id + offset;
    if (neighbourID.y <= _Resolution)
    {
        uint neighbourUID = getUID(neighbourID);
        Cube neighbour = _Cubes[neighbourUID];
        neighboursCount += neighbour.State;
    }
    // Positive Y.
    offset = int3(0,1,0);
    neighbourID = id + offset;
    if (neighbourID.y <= _Resolution)
    {
        uint neighbourUID = getUID(neighbourID);
        Cube neighbour = _Cubes[neighbourUID];
        neighboursCount += neighbour.State;
    }

    // Negative Z.
    offset = int3(0,0,-1);
    neighbourID = id + offset;
    if (neighbourID.z <= _Resolution)
    {
        uint neighbourUID = getUID(neighbourID);
        Cube neighbour = _Cubes[neighbourUID];
        neighboursCount += neighbour.State;
    }
    // Positive Z.
    offset = int3(0,0,1);
    neighbourID = id + offset;
    if (neighbourID.z <= _Resolution)
    {
        uint neighbourUID = getUID(neighbourID);
        Cube neighbour = _Cubes[neighbourUID];
        neighboursCount += neighbour.State;
    }

    return neighboursCount;
}

[numthreads(8,8,8)]
void InitRandom(uint3 id : SV_DispatchThreadID)
{
    int display = step(random(id.xyz), _InitRandomStep);
    
    uint uid = getUID(id);
    _Cubes[uid].Position = float3(id.xyz);
    _Cubes[uid].State = display;
}

[numthreads(8,8,8)]
void InitCenterCell(uint3 id : SV_DispatchThreadID)
{
    uint uid = getUID(id);
    _Cubes[uid].Position = float3(id.xyz);
    _Cubes[uid].State = id.x == _Resolution / 2 && id.y == _Resolution / 2 && id.z == _Resolution / 2 ? 1 : 0;
}

[numthreads(8,8,8)]
void ColorFromNeighbours(uint3 id : SV_DispatchThreadID)
{
    uint uid = getUID(id);
    _Cubes[uid].Position = float3(id.xyz);
    _Cubes[uid].Color = float3((_Rules.w == 0 ? getMooreNeighboursCount(id) : getNeumannNeighboursCount(id) / 26.0).xxx);
}

[numthreads(8,8,8)]
void Next(uint3 id : SV_DispatchThreadID)
{
    int uid = getUID(id);
    Cube cube = _Cubes[uid];
    int neighbours = _Rules.w == 0 ? getMooreNeighboursCount(id) : getNeumannNeighboursCount(id);

    if (cube.State == 0) // Dead.
    {
        if ((neighbours & _Rules.y) != 0 && _Rules.y > 0)
            _CubesBuffer[uid].State = 1;
    }
    else // Alive.
    {
        if ((neighbours & _Rules.x) == 0 && _Rules.x > 0)
            _CubesBuffer[uid].State = 0;
    }
}

[numthreads(8,8,8)]
void PrepareBuffer(uint3 id : SV_DispatchThreadID)
{
    int uid = getUID(id);
    _CubesBuffer[uid] = _Cubes[uid];
}

[numthreads(8,8,8)]
void ApplyBuffer(uint3 id : SV_DispatchThreadID)
{
    int uid = getUID(id);
    _Cubes[uid] = _CubesBuffer[uid];
}
